import sys
import os
import re
from constraint import *

problem = Problem()

class Parking_space:
    def __init__(self,emergency,Non_Urgent,electric):
        self.emergency = emergency
        self.Non_Urgent = Non_Urgent
        self.electric = electric

class Parking_row:
    def __init__(self, num_spaces):
        self.parking_spaces = [Parking_space(False,False,False) for _ in range(num_spaces)]

class Parking_lot:
    def __init__(self, num_rows, num_spaces_per_row):
        self.parking_rows = [Parking_row(num_spaces_per_row) for _ in range(num_rows)]

class Vehicle:
    def __init__(self, vehicle_id, type, freezer, location):
        self.id = vehicle_id
        self.type = type
        self.freezer = freezer
        self.location = location
def parse_file_content(content):
    lines = content.split('\n')

    # Parsing Rows and Columns
    rows, columns = map(int, re.findall(r'\d+', lines[0]))

    # Parsing Locations with connection to the electrical grid
    locations_line = lines[1].split(":")[1].strip()
    locations_electric = re.findall(r'\((\d+),(\d+)\)', locations_line)
    locations_electric = [(int(x),int(y)) for x, y in locations_electric]
    print(locations_electric)
    parking_lot = Parking_lot(rows,columns)
    for location in locations_electric:
        x, y = location
        parking_lot.parking_rows[x-1].parking_spaces[y-1].electric = True
    #Turn locations_electric into a list of numbers, being (1,1) number 1, (1,2) number 2, (2,1) number 3, etc
    locations_electric = [(x-1)*columns+y for x,y in locations_electric]
    print(locations_electric)
    #parking_spaces = [[Parking_space(False, False, False) for _ in range(columns)] for _ in range(rows)]

   
    # Setting the emergency and electric attributes based on input


    # Parsing Vehicle information
    vehicles = []
    for line in lines[2:]:
        vehicle = Vehicle(None, None, None, -1)
        if line:
            match = re.match(r'(\d+)-(\w+)-(\w+)', line)
            if match:
                vehicle_id, tipo, freezer = match.groups()
                vehicle.id = int(vehicle_id)
                vehicle.type = tipo
                vehicle.freezer = freezer
                vehicle.location = vehicle.id
                vehicles.append(vehicle)

    return parking_lot, vehicles, rows, columns, locations_electric


def read_file(file_path):
    try:
        with open(file_path, 'r') as file:
            content = file.read()
            return content
    except FileNotFoundError:
        print(f"Error: File '{file_path}' not found.")
        sys.exit(1)

# Create a problem instance


def main():
    def TSU_get_out(x,y):
        if (y-1)%columns > (x-1)%columns and (y-1)//columns == (x-1)//columns:
            return (y-1)//columns != (x-1)//columns
        else:
            return True
    def Manoeuvrability(x,y):
        if (x-1)//columns == rows-1:
            return y != x - columns
        elif (x-1)//columns == 0:
            return y != x + columns
        else:
            return( y!= x + columns or y != x - columns)

    def get_location(vehicle_id):
        for vehicle in vehicles:
            if vehicle.id == vehicle_id:
                return int(vehicle.location)
    if len(sys.argv) != 2:
        print("Usage: python parking_script.py <file_path>")
        sys.exit(1)

    file_path = sys.argv[1]
    file_content = read_file(file_path)
    parking_lot, vehicles, rows, columns, locations_electric = parse_file_content(file_content)

    print("\nVehicle Information:")
    for vehicle in vehicles:
        print(vehicle.id, vehicle.type, vehicle.freezer, vehicle.location)
    print("\nparking_lot information")
    for i in parking_lot.parking_rows:
        for j in i.parking_spaces:
            print(j.electric," ",j.emergency," ",j.Non_Urgent,"\n")

    print("\n\n\nNow Restrictions\n\n\n")
    problem = Problem()

    # Add variables to the problem
    # Each parking space is a variable, and the domain of each variable is the set of all vehicles
    # for row in range(rows):
    #     for column in range(columns):
    # Create an array from 1 to rows*columns
    locations = []  # Define the "locations" list
    for i in range(rows * columns):
        locations.append(int(i + 1))
    print("\nVariables\n")
    for vehicle in vehicles:
        if vehicle.freezer == 'C':
            problem.addVariable(vehicle.id, locations_electric)
        elif vehicle.freezer == 'X':
            problem.addVariable(vehicle.id, locations)

    # Constraint 2: Two different vehicles cannot take the same location.
    print("Constraint 2: Two different vehicles cannot take the same location.")
    problem.addConstraint(AllDifferentConstraint())
    #Constraint 4: . A TSU vehicle cannot have any other vehicle parked in front of it, in the same row, except if it is also another TSU vehicle
    print("Constraint 4: . A TSU vehicle cannot have any other vehicle parked in front of it, in the same row, except if it is also another TSU vehicle")
    for vehicle1 in vehicles:
        for vehicle2 in vehicles:
            if vehicle1.id != vehicle2.id:
                if vehicle1.type == "TSU" and vehicle2.type == "TNU":
                    problem.addConstraint(TSU_get_out, (vehicle1.id, vehicle2.id))
                    #print("The vehicle 1: ",vehicle1.id," and vehicle 2: ",vehicle2.id," cannot be in : ",vehicle1.location + i," ",vehicle2.location)
    #Constraint 5: Maneuvrability constraint
    print("Constraint 5: Maneuvrability constraint")
    for vehicle1 in vehicles:
        for vehicle2 in vehicles:
            if vehicle1.id != vehicle2.id:
                problem.addConstraint(Manoeuvrability, (vehicle1.id,vehicle2.id))
    sol = problem.getSolutions()

    #for i in sol:
        #print(i)
    print(len(sol))
    #print(len(problem.getSolutions()))
    #Compute how many there are
    #print(sol)
    #problem.addVariables(vehicles_id, range(rows*columns))
    # Add constraints to the problem

    # Constraint 1: Every vehicle must be assigned one location and only one.
    #print("\nConstraints\n")
    #print("Constraint 1: Every vehicle must be assigned one location and only one.")
    #for vehicle_id in vehicles_id:
    #    problem.addConstraint(lambda x, vehicle_id=vehicle_id: x == vehicle_id, vehicle_id)

    
    # Constraint 3: Vehicles equipped with a freezer can only take a location with connection to the electrical network.
    #for row in range(rows):
    #    for column in range(columns):
    #        if not parking_lot.parking_rows[row].parking_spaces[column].electric:
    #            problem.addConstraint(lambda x, parking_lot.parking_rows[row].parking_spaces[column] = parking_lot.parking_rows[row].parking_spaces[column] : x != freezer_vehicle, [parking_lot.parking_rows[row].parking_spaces[column]])
    # Constraints 4 and 5 would be similar, but would require more complex constraint functions

    #constraint 3
    #print("Constraint 3: Vehicles equipped with a freezer can only take a location with connection to the electrical network.")
    #for vehicle_id, tipo, freezer in vehicles:
    #    if freezer == "C":
    #        problem.addConstraint(lambda x, vehicle_id=vehicle_id: parking_lot.parking_rows[x//columns].parking_spaces[x%columns].electric, [vehicle_id])
    #freezers = [freezer for _, _, freezer in vehicles]
    #print(freezers)
    # Get the solutions to the problem
    #print("Solutions")
    #solutions = problem.getSolutions()
    #print (" #{0} solutions have been found: ".format (len (solutions)))
    #for s in solutions:
    #    print (s)
if __name__ == "__main__":
    main()
